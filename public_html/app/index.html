
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Digital Marketing Agency Website</title>
    <link rel="icon" href="/favicon.png" />
    <script type="module" crossorigin src="/app/assets/index-QEwpcKfR.js"></script>
      <link rel="stylesheet" crossorigin href="/app/assets/index-CCC3l2Od.css">
    </head>

    <body>
      <div id="root"></div>

      <script>
      (function() {
        // Redirect "About" and "Services" buttons to their respective pages
        function setupNavbarRedirects() {
            const handleRedirects = () => {
                 // Helper to setup redirect for a button/link with specific text
                 const setupRedirect = (text, targetUrl) => {
                     const upperText = text.toUpperCase();
                     
                     // Buttons
                     const buttons = Array.from(document.querySelectorAll('button'));
                     const targetBtn = buttons.find(b => b.textContent.trim().toUpperCase() === upperText || b.textContent.trim() === text);
                     
                     if (targetBtn && !targetBtn.dataset.redirectParams) {
                         const newBtn = targetBtn.cloneNode(true);
                         targetBtn.parentNode.replaceChild(newBtn, targetBtn);
                         newBtn.dataset.redirectParams = 'true';
                         newBtn.addEventListener('click', (e) => {
                             e.preventDefault();
                             e.stopPropagation();
                             window.location.href = targetUrl;
                         });
                     }
                     
                     // Links
                     const links = Array.from(document.querySelectorAll('a'));
                     const targetLink = links.find(l => l.textContent.trim().toUpperCase() === upperText || l.textContent.trim() === text);
                     
                     if (targetLink && !targetLink.dataset.redirectParams) {
                         const newLink = targetLink.cloneNode(true);
                         targetLink.parentNode.replaceChild(newLink, targetLink);
                         newLink.href = targetUrl;
                         newLink.dataset.redirectParams = 'true';
                     }
                 };

                 const removeElement = (text) => {
                     const upperText = text.toUpperCase();
                     
                     // Buttons
                     const buttons = Array.from(document.querySelectorAll('button'));
                     const targetBtn = buttons.find(b => b.textContent.trim().toUpperCase() === upperText || b.textContent.trim() === text);
                     
                     if (targetBtn) {
                         targetBtn.remove();
                     }
                     
                     // Links
                     const links = Array.from(document.querySelectorAll('a'));
                     const targetLink = links.find(l => l.textContent.trim().toUpperCase() === upperText || l.textContent.trim() === text);
                     
                     if (targetLink) {
                         targetLink.remove();
                     }
                 };

                 setupRedirect('About', '/about.html');
                 setupRedirect('Services', '/services.html');
                 removeElement('Work');
            };

            handleRedirects();

            const observer = new MutationObserver((mutations) => {
                handleRedirects();
            });
            
            observer.observe(document.body, { childList: true, subtree: true });
        }
        
        window.addEventListener('load', setupNavbarRedirects);
        setupNavbarRedirects();

        // Trusted Brands Slider Logic
        async function updateTrustedBrands() {
          try {
            const waitForCarousel = () => new Promise(resolve => {
              const check = () => {
                const carousel = document.querySelector('[data-slot="carousel-content"] > div');
                if (carousel) resolve(carousel);
                else requestAnimationFrame(check);
              };
              check();
            });

            const carouselTrack = await waitForCarousel();
            const response = await fetch('/api/trusted-brands');
            if (!response.ok) throw new Error('Failed to fetch brands');
            const json = await response.json();
            const brands = json.data || json;

            if (!brands || brands.length === 0) return;

            carouselTrack.innerHTML = '';

            brands.forEach(brand => {
              const slide = document.createElement('div');
              slide.setAttribute('role', 'group');
              slide.setAttribute('aria-roledescription', 'slide');
              slide.setAttribute('data-slot', 'carousel-item');
              slide.className = 'min-w-0 shrink-0 grow-0 pl-4 basis-1/2 sm:basis-1/3 md:basis-1/4 lg:basis-1/6';

              const inner = document.createElement('div');
              inner.className = 'flex items-center justify-center rounded-xl';
              inner.style.height = '80px';
              inner.style.background = 'rgba(255, 255, 255, 0.02)';
              inner.style.border = '1px solid rgba(255, 255, 255, 0.06)';

              const img = document.createElement('img');
              img.src = brand.image_url;
              img.alt = brand.name;
              img.className = 'max-h-full max-w-full object-contain';
              img.style.filter = 'grayscale(100%) brightness(10)';
              img.style.opacity = '0.35';

              inner.appendChild(img);
              slide.appendChild(inner);
              carouselTrack.appendChild(slide);
            });
          } catch (e) {
            console.error('Error updating trusted brands slider:', e);
          }
        }

        window.addEventListener('load', updateTrustedBrands);
        const observer = new MutationObserver((mutations) => {
           if (document.querySelector('[data-slot="carousel-content"] > div')) {
               observer.disconnect();
               updateTrustedBrands();
           }
        });
        observer.observe(document.body, { childList: true, subtree: true });

        // Favicon Upload Logic (Admin Only)
        function initFaviconUploader() {
            // Check if user is in admin dashboard
            if (!window.location.href.includes('/admin') && !window.location.href.includes('/dashboard')) return;

            // Check if already added to avoid duplicates
            if (document.getElementById('seo-favicon-row')) return;
            
            // TARGETING STRATEGY:
            // 1. Prioritize finding the specific SEO preview card div described by the user.
            //    User described it as: background: rgba(255, 255, 255, 0.03), border: 1px solid rgba(255, 255, 255, 0.05)
            // 2. Fallback to finding the 'Meta Description' label.

            const allDivs = Array.from(document.querySelectorAll('div'));
            let targetDiv = allDivs.find(div => {
                // We look for the unique style signature of the SEO preview card
                // Check inline styles first (fastest)
                const styleAttr = div.getAttribute('style') || '';
                if (styleAttr.includes('0.03') && styleAttr.includes('0.05')) return true;
                
                // Check computed styles (only if it has suggestive classes to avoid perf hit)
                if (div.className.includes('rounded-xl') || div.className.includes('border')) {
                    const style = window.getComputedStyle(div);
                    // Check for the specific alpha values in background and border
                    // Browsers might return rgba(255, 255, 255, 0.03)
                    return (style.backgroundColor.includes('0.03') && style.borderColor.includes('0.05'));
                }
                return false;
            });

            let insertionPoint = null;
            let parentContainer = null;

            if (targetDiv) {
                // If we found the preview card, we want to insert BEFORE it
                insertionPoint = targetDiv;
                parentContainer = targetDiv.parentElement;
            } else {
                // Fallback: Find by Label
                const labels = Array.from(document.querySelectorAll('label'));
                const anchorLabel = labels.find(l => 
                    l.innerText.includes('Meta Description') || 
                    l.innerText.includes('Meta Title')
                );
                
                if (anchorLabel) {
                    let formGroup = anchorLabel.parentElement;
                    // Heuristic: usually form groups are divs.
                    if (formGroup.tagName === 'DIV' && formGroup.children.length < 3) {
                         // This seems like a wrapper
                    }
                    
                    // In fallback mode, we append AFTER the form group
                    parentContainer = formGroup.parentElement;
                    insertionPoint = formGroup.nextSibling;
                }
            }
            
            if (parentContainer) {
                // Create the new row
                const container = document.createElement('div');
                container.id = 'seo-favicon-row';
                // Use standard form group styling to blend in, with flex layout for preview
                container.className = 'flex items-center gap-4 mt-4 mb-4'; 
                
                container.innerHTML = `
                    <div class="relative shrink-0">
                        <img id="favicon-preview" src="/favicon.png?t=${new Date().getTime()}" 
                             alt="Favicon" 
                             class="h-12 w-12 object-contain rounded-lg border border-white/10 bg-white/5" 
                             onerror="this.style.display='none'">
                    </div>
                    <div class="grid w-full max-w-sm items-center gap-1.5">
                        <label class="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">Favicon</label>
                        <div class="flex items-center gap-3">
                            <button id="seo-upload-btn" type="button" class="inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 bg-blue-600 text-white shadow hover:bg-blue-700 h-9 px-4 py-2">
                                Upload Image
                            </button>
                            <span id="upload-status" class="text-xs text-gray-500">PNG or ICO</span>
                        </div>
                        <input type="file" id="seo-favicon-input" accept="image/png, image/x-icon" style="display: none;">
                    </div>
                `;
                
                parentContainer.insertBefore(container, insertionPoint);
                
                // Event listeners
                const btn = container.querySelector('#seo-upload-btn');
                const input = container.querySelector('#seo-favicon-input');
                const status = container.querySelector('#upload-status');
                const preview = container.querySelector('#favicon-preview');
                
                if (btn && input) {
                    btn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        input.click();
                    };
                    
                    input.onchange = async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        const formData = new FormData();
                        formData.append('favicon', file);
                        
                        btn.disabled = true;
                        btn.innerText = '...';
                        
                        try {
                            // Smart Token Finder
                            const findToken = () => {
                                const candidates = ['token', 'auth_token', 'access_token', 'jwt', 'bearer'];
                                // Direct check
                                for (const key of candidates) {
                                    if (localStorage.getItem(key)) return localStorage.getItem(key);
                                    if (sessionStorage.getItem(key)) return sessionStorage.getItem(key);
                                }
                                // Pattern check (Sanctum 1|... or JWT ey...)
                                const patterns = [/^\d+\|/, /^eyJ/]; 
                                const check = (storage) => {
                                    for (let i = 0; i < storage.length; i++) {
                                        const key = storage.key(i);
                                        const val = storage.getItem(key);
                                        if (patterns.some(p => p.test(val))) return val;
                                        try {
                                            const parsed = JSON.parse(val);
                                            if (parsed && typeof parsed === 'object') {
                                                if (parsed.token) return parsed.token;
                                                if (parsed.access_token) return parsed.access_token;
                                                if (parsed.state && parsed.state.token) return parsed.state.token; // Zustand/Redux
                                            }
                                        } catch {}
                                    }
                                    return null;
                                };
                                return check(localStorage) || check(sessionStorage);
                            };

                            const token = findToken();
                            
                             // Get XSRF token for cookie-based auth (Sanctum)
                            const getCookie = (name) => {
                                const value = `; ${document.cookie}`;
                                const parts = value.split(`; ${name}=`);
                                if (parts.length === 2) return parts.pop().split(';').shift();
                            };
                            const xsrfToken = getCookie('XSRF-TOKEN');
                                         
                            const headers = { 'Accept': 'application/json' };
                            if (token) headers['Authorization'] = `Bearer ${token}`;
                            if (xsrfToken) headers['X-XSRF-TOKEN'] = decodeURIComponent(xsrfToken);
                    
                            console.log('Uploading favicon...', { hasToken: !!token, hasXsrf: !!xsrfToken });

                            // Debug Auth
                            try {
                                const debugResponse = await fetch('/api/debug-auth', {
                                    headers: headers,
                                    credentials: 'include'
                                });
                                const debugData = await debugResponse.json();
                                console.log('Auth Debug:', debugData);
                                if (!debugData.user && !token) {
                                    alert('Session expired or not logged in. Please refresh the page and log in again.');
                                    return;
                                }
                            } catch (e) {
                                console.error('Auth check failed:', e);
                            }
 
                            const response = await fetch('/api/settings/favicon', {
                                method: 'POST',
                                body: formData,
                                headers: headers,
                                credentials: 'include' // Important for Sanctum cookie-based auth
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                const newSrc = '/favicon.png?t=' + new Date().getTime();
                                
                                // Update status
                                status.innerText = 'Saved!';
                                status.className = 'text-xs text-green-600 font-bold';
                                
                                // Update preview immediately
                                if (preview) {
                                    preview.src = newSrc;
                                    preview.style.display = 'block';
                                }
                                
                                // Update site favicon immediately
                                let link = document.querySelector("link[rel~='icon']");
                                if (!link) {
                                    link = document.createElement('link');
                                    link.rel = 'icon';
                                    document.head.appendChild(link);
                                }
                                link.href = newSrc;
                                
                                setTimeout(() => window.location.reload(), 1500);
                            } else {
                                const err = await response.json().catch(() => ({}));
                                status.innerText = 'Failed';
                                status.className = 'text-xs text-red-600';
                                console.error(err);
                            }
                        } catch (error) {
                            status.innerText = 'Error';
                            console.error(error);
                        } finally {
                            btn.disabled = false;
                            if (status.innerText !== 'Saved!' && status.innerText !== 'Failed') {
                               btn.innerText = 'Upload Image';
                            }
                            input.value = '';
                        }
                    };
                }
            }
        }


        
        setInterval(initFaviconUploader, 1000);
      })();
    </script>

      <script src="/app/js/projects.js"></script>
    </body>
  </html>
  
